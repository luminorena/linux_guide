## Содержание

### Часть IV Сценарии командной оболочки
- [Глава 24. Создание первого сценария командной оболочки](#глава-14-создание-первого-сценария-командной-оболочки)
- [Глава 25. Начало проекта](#глава-25-начало-проекта)

## Глава 24. Создание первого сценария командной оболочки

### Что такое сценарии командной оболочки

Выражаясь простым языком, сценарий командной оболочки — это файл, содержащий последовательность команд. Командная оболочка читает этот файл и выполняет команды, как если бы они вводились вручную в командной строке.
Командная оболочка — это одновременно и мощный интерфейс командной строки к системе, и интерпретатор языка сценариев. 

### Как написать сценарий командной оболочки

Чтобы успешно создать и запустить сценарий командной оболочки, нам нужно:
1. Написать сценарий. Сценарии командной оболочки — это обычные текстовые
файлы. Поэтому для их создания нам понадобится текстовый редактор. Лучше
использовать текстовый редактор, обладающий функцией подсветки синтаксиса, позволяющей видеть элементы сценариев с цветной маркировкой. Подсветка синтаксиса помогает замечать некоторые типичные ошибки. Для создания сценариев хорошо подходят vim, gedit, kate и многие другие редакторы.
2. Сделать сценарий выполняемым. Система не позволяет интерпретировать
любой старый текстовый файл как программу, и небезосновательно! Поэтому,
чтобы выполнить сценарий, файлу сценария нужно дать разрешения на выполнение.
3. Поместить сценарий в каталог, где командная оболочка сможет найти его.
Командная оболочка автоматически ищет выполняемые файлы в нескольких
каталогах, если путь к файлу не указан явно. Для максимального удобства мы
будем помещать наши сценарии в такие каталоги.


###  Формат файла сценария

Следуя традициям программирования, напишем программу «hello world», чтобы
продемонстрировать чрезвычайно простой сценарий. Итак, запустите текстовый
редактор и введите следующий сценарий:

```
#!/bin/bash
# Это наш первый сценарий.
echo 'Hello World!'
```

Последняя строка в сценарии хорошо знакома — это простая команда echo со
строковым аргументом. Вторая строка также знакома. Она выглядит как комментарии, которые мы видели во многих конфигурационных файлах, исследованных и отредактированных нами. Еще одна особенность комментариев, о которой пока не рассказывалось, — они могут появляться в концах строк, если им предшествует хотя бы один пробельный символ, например:

```
echo 'Hello World!' # Это тоже комментарий
```

Все, начиная с символа # и до конца строки, игнорируется.
То же самое верно и для командной строки:


```
[me@linuxbox ~]$ echo 'Hello World!' # Это тоже комментарий
Hello World!
```

Первая строка в сценарии смотрится несколько необычно. Она похожа на ком-
ментарий, потому что начинается с символа #, но выглядит какой-то уж слишком специальной, чтобы быть комментарием. Последовательность символов #! — это на самом деле специальная конструкция, которая называется shebang (произносится как «шебанг») и сообщает системе имя интерпретатора, который должен использоваться для выполнения следующего за ним текста сценария. Каждый сценарий командной оболочки должен включать это определение в первой строке. Сохраните файл сценария с именем hello_world.

### Разрешения на выполнение

Далее сделаем сценарий исполняемым при помощи команды chmod:

```
[me@linuxbox ~]$ ls -l hello_world
-rw-r--r-- 1 me
me
63 2018-03-07 10:10 hello_world
[me@linuxbox ~]$ chmod 755 hello_world
[me@linuxbox ~]$ ls -l hello_world
-rwxr-xr-x 1 me
me
63 2018-03-07 10:10 hello_world
```

Существует два распространенных набора разрешений для сценариев: 755 — для
сценариев, которые должны быть доступны для выполнения всем, и 700 — для
сценариев, которые могут выполняться только владельцами. Обратите внимание,
что сценарии необходимо сделать доступными для чтения, чтобы их можно было
выполнить.

### Местоположение файла сценария

После установки разрешений попробуем запустить сценарий:

```
[me@linuxbox ~]$ ./hello_world
Hello World!
```
Но чтобы это сделать, необходимо добавить явный путь перед его именем. В противном случае мы получим следующее сообщение:
```
[me@linuxbox ~]$ hello_world
bash: hello_world: команда не найдена
```

В чем причина? Проблема — местоположение. Ранее мы изучали переменную окружения PATH и ее влияние на то, как система ищет выполняемые программы. Коротко напомним, что система просматривает каталоги по списку всякий раз, когда требуется найти исполняемую программу, если путь к ней не указан явно. Именно так система выполняет программу /bin/ls, если мы вводим ls в командной строке. Каталог /bin — один из каталогов, которые система просматривает автоматически. Список каталогов хранится в переменной
окружения PATH. Она содержит список каталогов, перечисленных через двоето-
чие. Увидеть, что содержится в PATH, можно с помощью команды:

```
[me@linuxbox ~]$ echo $PATH
/home/me/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
```

Как видите, это просто список каталогов. Если поместить сценарий в любой из
этих каталогов, наша проблема будет решена. Обратите внимание на первый ка-
талог в списке, /home/me/bin. В большинстве дистрибутивов Linux в переменную PATH включается каталог bin в домашнем каталоге пользователя, чтобы дать пользователям возможность выполнять собственные программы. То есть если создать каталог bin и поместить сценарий в него, его можно будет запускать как любые другие программы:
```
[me@linuxbox ~]$ mkdir bin
[me@linuxbox ~]$ mv hello_world bin
[me@linuxbox ~]$ hello_world
Hello World!
```
Если каталог отсутствует в переменной PATH, его легко туда добавить, включив следующую строку в файл .bashrc:
export PATH=~/bin:"$PATH"

Это изменение будет действовать в каждом последующем сеансе работы с терминалом. Чтобы применить изменения в текущем сеансе, нужно заставить командную оболочку повторно прочитать файл .bashrc, например, так:

```
[me@linuxbox ~]$ . .bashrc
```

Команда «точка» (.) является синонимом source, встроенной команды, которая
читает указанный файл и интерпретирует его как ввод с клавиатуры.

#### ПРИМЕЧАНИЕ

Ubuntu (и многие другие дистрибутивы на основе Debian) автоматически добавляет каталог ~/bin в переменную PATH, если он существует в момент выполнения файла .bashrc. То есть если в системе Ubuntu создать каталог ~/bin и затем выйти и войти в систему, проблема решится автоматически.

### НАСТРОЙКА VIM ДЛЯ РАЗРАБОТКИ СЦЕНАРИЕВ

Текстовый редактор vim имеет много, очень много параметров настройки. Некоторые из них можно использовать для подготовки редактора к разработке
сценариев. 
Следующая команда:

:syntax on
включает подсветку синтаксиса. С этой настройкой редактор будет отображать
синтаксические элементы сценариев разным цветом. Это помогает выявлять некоторые виды ошибок. И конечно же, выглядит очень круто. Обратите внимание, что для работы этой настройки должна быть установлена полная версия vim, а редактируемый файл должен содержать строку шебанг (shebang), сообщающую, что файл является сценарием командной оболочки. Если с этой командой возникнут сложности, попробуйте настройку :set syntax=sh.

:set hlsearch
включает подсветку результатов поиска. Например, если выполнить поиск слова
echo с этой настройкой, редактор выделит все вхождения искомого слова.

:set tabstop=4
определяет число колонок (знакомест), занимаемых символом табуляции. По
умолчанию один символ табуляции занимает восемь знакомест. Присвоив этому
параметру значение 4, вам проще будет уместить длинные строки на экране.

:set autoindent
включает автоматическое оформление отступов. Этот параметр заставляет vim
добавлять в новую строку отступ, как в строке выше. Это ускоряет ввод многих видов программных конструкций. Чтобы прекратить автоматическое выравнивание, достаточно нажать комбинацию CTRL+D.
Эти изменения можно сделать постоянными, добавив описанные команды (без
начального двоеточия) в файл ~/.vimrc.

### Выбор местоположения для сценариев

Каталог ~/bin хорошо подходит для сценария, если этот сценарий предназначен для личного использования. Сценарии, которые должны быть доступны всем пользователям в системе, лучше размещать в традиционном месте — в каталоге /usr/local/bin. 
Сценарии, предназначенные для использования системным администратором, часто помещаются в каталог /usr/local/sbin.
В большинстве случаев программное обеспечение, созданное в локальной системе, будь то сценарии или скомпилированные программы, следует помещать в иерархию каталогов /usr/local, а не /bin или /usr/bin. Последние два каталога, как определено стандартом иерархии файловой системы Linux, предназначены только для файлов, поставляемых создателями дистрибутива Linux.

### Дополнительные хитрости по оформлению

Одной из ключевых целей, стоящих перед создателями сценариев, является простота сопровождения, то есть простота, с которой сценарий может быть изменен автором или другими пользователями для удовлетворения меняющихся потребностей. Один из способов упростить сопровождение — улучшить читаемость и понятность сценария.

### Длинные имена параметров
Многие команды, с которыми мы уже знакомы, поддерживают параметры с короткими и длинными именами. Например, команда ls имеет множество параметров, которые можно выразить в короткой и в длинной форме. Например:

```
[me@linuxbox ~]$ ls -ad
и
[me@linuxbox ~]$ ls --all --directory
```

это эквивалентные команды. Параметры с короткими именами предпочтительнее
использовать в командной строке, так как они помогают уменьшить ручной ввод, но длинные имена параметров могут улучшить читаемость.


### Отступы и продолжения строк
Если приходится использовать длинные команды, их читаемость можно повы-
сить, распределяя такие команды по нескольким строкам. Ранее был представлен пример длинной команды find:

```
[me@linuxbox ~]$ find playground \( -type f -not -perm 0600 -exec
chmod 0600 '{}' ';' \) -or \( -type d -not -perm 0700 -exec chmod
0700 '{}' ';' \)
```

С первой попытки понять эту команду очень сложно. В тексте сценария ее можно упростить, записав следующим образом:

```
find playground \
\( \
-type f \
-not -perm 0600 \
-exec chmod 0600 '{}' ';' \
\) \
-or \
\( \
-type d \
-not -perm 0700 \
-exec chmod 0700 '{}' ';' \
\)
```

С помощью последовательностей продолжения строки (включающих обратный
слеш и символ перевода строки) и отступов логику этой сложной команды удалось сделать ясной для читателя. Этот прием работает также в командной строке, однако он редко используется из-за неудобства ввода и редактирования. Одно из отличий сценариев от командной строки — возможность использования символов табуляции для оформления отступов, тогда как в командной строке это невозможно, потому что клавиша ввода табуляции активирует функцию автодополнения.

### Заключение

В первой главе, посвященной сценариям, мы увидели, как писать сценарии и как упростить их запуск в своей системе. Мы также познакомились с некоторыми приемами оформления, улучшающими читаемость (и тем самым упрощающими сопровождение) сценариев. В следующих главах мы снова и снова будем возвращаться к простоте сопровождения как главному принципу создания качественных сценариев.

## Глава 25. Начало проекта

Далее мы напишем генератор отчетов. Он будет выводить разнообразную информацию о системе и ее состоянии в формате HTML, благодаря чему ее можно
будет просматривать в веб-браузере. Обычно создание программ выполняется в несколько этапов, на каждом из которых добавляются новые функции и возможности. 
По окончании первого этапа наша программа будет воспроизводить минимальную HTML-страницу без какой-либо информации. Эту информацию мы добавим на следующих этапах.

Этап первый: минимальный документ
Прежде всего, определим, как выглядит формат правильно сформированного
HTML-документа. Он имеет следующий вид:

```
<html>
  <head>
    <title>Заголовок страницы</title>
  </head>
  <body>
    Тело страницы.
  </body>
</html>
```

Если ввести этот текст в текстовом редакторе и сохранить в файле с именем foo.html, мы сможем открыть его, введя следующий адрес URL в Firefox: file:///home/username/foo.html.


На первом этапе создадим программу, которая будет выводить эту разметку
HTML в стандартный вывод. Написать такую программу очень просто. Откройте
текстовый редактор и создайте файл с именем ~/bin/sys_info_page:
[me@linuxbox ~]$ vim ~/bin/sys_info_page
А затем введите следующую программу:

```
#!/bin/bash
# Программа вывода страницы с информацией о системе
echo "<html>"
echo " <head>"
echo "
<title>Page Title</title>"
echo " </head>"
echo " <body>"
echo "
Page body."
echo " </body>"
echo "</html>"
```
Наша первая версия содержит строку-шебанг (shebang), комментарий и последовательность команд echo, по одной для вывода
каждой строки. После сохранения файла сделайте его выполняемым и попробуйте запустить:

```
[me@linuxbox ~]$ chmod 755 ~/bin/sys_info_page
[me@linuxbox ~]$ sys_info_page
```

После запуска на экране должен появиться текст HTML-документа, потому что
команды echo в сценарии посылают свои строки в стандартный вывод. Запустите программу снова и перенаправьте вывод программы в файл sys_info_page.html, чтобы затем посмотреть результат в веб-браузере:

```
[me@linuxbox ~]$ sys_info_page > sys_info_page.html
[me@linuxbox ~]$ firefox sys_info_page.html
```

Пока все идет неплохо.
Разрабатывая программы, всегда следует помнить о простоте и ясности. Если объединить все команды echo в одну, это определенно упростит в будущем добавление новых строк в вывод программы. Поэтому изменим программу, как показано ниже:

```
#!/bin/bash
# Программа вывода страницы с информацией о системе

echo "<html>
<head>
  <title>Page Title</title>
</head>
<body>
  Page body.
</body>
</html>"
```

Строки в кавычках могут включать символы перевода строки и, соответственно,
содержать несколько строк текста. Командная оболочка будет продолжать читать текст, пока не встретит закрывающую кавычку. Это правило действует также в командной строке:

```
[me@linuxbox ~]$ echo "<html>
>  <head>
>    <title>Page Title</title>
>  </head>
>  <body>
>    Page body.
>   </body>
>  </html>
EOF

```

Символ > в начале каждой строки — это приглашение к вводу командной оболочки, определяемое ее переменной PS2. Оно появляется всякий раз, когда происходит ввод многострочной инструкции, то есть, когда нажимается Enter. Эта особенность пока малопонятна, но потом, когда мы познакомимся с многострочными программными инструкциями, ее преимущества станут очевидными.

### Этап второй: добавление некоторых данных

Теперь, когда программа способна сгенерировать минимальный документ, добавим в отчет немного данных. Для этого внесите следующие изменения:

```
#!/bin/bash
# Программа вывода страницы с информацией о системе

echo "<html>
  <head>
    <title>System Information Report</title>
  </head>
  <body>
    <h1>System Information Report</h1>
  </body>
</html>"
```

Здесь добавлено название страницы и заголовок в теле отчета.

### Переменные и константы

В нашем сценарии возникла проблема. Обратили внимание, что строка System
Information Report повторяется дважды? Вообще, для такого крохотного сценария это не такая большая проблема, но представьте по-настоящему длинный сценарий, в котором эта строка повторяется много раз. Если в таком сценарии понадобится изменить название, придется внести изменения во множестве мест,а это масса ручной работы. Можно ли изменить сценарий так, чтобы строка определялась в нем только один раз? Это существенно упростило бы сопровождение сценария в будущем. Да, это возможно, например, так:

```
#!/bin/bash

title="System Information Report"

# Программа вывода страницы с информацией о системе

echo "<html>
  <head>
    <title>$title</title>
  </head>
  <body>
    <h1>$title</h1>
  </body>
</html>"
```

Создав переменную с именем title и присвоив ей значение System Information
Report, мы воспользовались преимуществами подстановки параметров и поместили строку во множество мест. Но как создать переменную? Просто — достаточно использовать ее. <b>Когда командная оболочка встречает переменную, она автоматически создает ее.</b> Этим она отличается от многих языков программирования, в которых переменные должны явно объявляться или определяться до ее использования. Командная оболочка слишком либеральна в этом отношении, что в итоге приводит к некоторым про-
блемам. Например, рассмотрим следующий сценарий, выполненный в команд-
ной строке:

```
[me@linuxbox ~]$ foo="yes"
[me@linuxbox ~]$ echo $foo
yes
[me@linuxbox ~]$ echo $fool
[me@linuxbox ~]$
```

Мы сначала присвоили значение yes переменной foo и затем вывели ее значение командой echo. Далее, мы попробовали вновь вывести значение переменной, но допустили опечатку, указав имя fool, и получили пустую строку. Такой результат объясняется тем, что командная оболочка благополучно создала переменную fool, встретив ее, и присвоила ей пустое значение по умолчанию. Из этого примера следует, что нужно внимательно следить за правописанием!
Также важно понять, что в действительности произошло в этом примере. Из
предыдущего знакомства с особенностями работы механизма подстановки мы
знаем, что команда

```
[me@linuxbox ~]$ echo $foo
```

подвергается действию механизма подстановки параметров, в результате чего
приобретает вид

```
[me@linuxbox ~]$ echo yes
```

С другой стороны, команда

```
[me@linuxbox ~]$ echo $fool
```
превращается в

```
[me@linuxbox ~]$ echo
```

На место пустой переменной ничего не подставляется! Это может вызвать ошибку в командах, требующих наличия аргументов. Например:

```
[me@linuxbox ~]$ foo=foo.txt
[me@linuxbox ~]$ foo1=foo1.txt
[me@linuxbox ~]$ cp $foo $fool
```
cp: после 'foo.txt' пропущен операнд, задающий целевой файл
По команде "cp --help" можно получить дополнительную информацию.

Мы присвоили значения двум переменным, foo и foo1. А затем попытались выполнить команду cp, но допустили опечатку в имени второго аргумента. После обработки механизмом подстановки команда cp получила только один аргумент, хотя требует двух.

Ниже приводятся несколько правил именования переменных:
1. Имена переменных могут состоять из алфавитно-цифровых символов (букв
и цифр) и символов подчеркивания.
2. Первый символ в имени переменной может быть только буквой или символом
подчеркивания.
3. Присутствие пробелов и знаков препинания в именах переменных не допускается.

Название переменная подразумевает значение, которое может изменяться, и во
многих приложениях переменные именно так и используются. Однако переменная title в нашем приложении используется как константа. Константа,
так же как переменная, имеет имя и содержит значение. Отличие лишь в том,
что значение константы не изменяется. В приложении, осуществляющем геометрические расчеты, можно определить константу PI со значением 3.1415, вместо того, чтобы использовать это число по всей программе. Командная оболочка не различает константы и переменные; эти термины используются в основном для удобства программиста. Типичное соглашение — использовать буквы верхнего регистра для обозначения констант и буквы нижнего регистра для истинных переменных. Давайте изменим сценарий, приведя его в соответствие с этим соглашением:

```
#!/bin/bash

TITLE="System Information Report For $HOSTNAME"

# Программа вывода страницы с информацией о системе

echo "<html>
  <head>
    <title>$TITLE</title>
  </head>
  <body>
    <h1>$TITLE</h1>
  </body>
</html>"
```

Попутно мы дополнили название, добавив в конец значение переменной командной оболочки HOSTNAME. Это — сетевое имя машины.

### ПРИМЕЧАНИЕ

В действительности командная оболочка имеет механизм, гарантирующий неизменяемость констант, в виде встроенной команды declare с параметром -r
(read-only — только для чтения). Если переменной TITLE присвоить значение,
как показано ниже:

```
declare -r TITLE="Page Title"
```

командная оболочка не допустит повторного присваивания значения переменной TITLE. Этот механизм редко используется на практике, но он имеется и его
можно применять в особенно строгих сценариях.

### Присваивание значений переменным и константам

Мы подошли к моменту, когда наше знание особенностей работы механизма под-
становки начинает приносить свои плоды. Как мы видели, присваивание значе-
ний переменным производится так:

переменная=значение
где переменная — это имя переменной, а значение — строка. 

В отличие от некоторых других языков программирования, командная оболочка не заботится о типах значений, присваиваемых переменным; она все значения интерпретирует как строки. Существует возможность заставить командную оболочку ограничить круг присваиваемых значений целыми числами, задействовав команду declare с параметром -i, но, как и объявление переменных, доступных только для чтения, эта возможность редко используется на практике.

Обратите внимание на отсутствие пробелов в операторе присваивания между
именем переменной, знаком «равно» и значением. А из чего может состоять значение? Из всего что угодно, что можно развернуть в строку.

```
a=z
# Присвоит переменной a строку "z".
b="a string"
# Внутренние пробелы должны находиться в кавычках.
c="a string and $b" # При присваивании допускается выполнять подстановку,
# например, значений других переменных.
d=$(ls -l foo.txt) # Результат выполнения команды.
e=$((5 * 7))
# Подстановка результата арифметического выражения.
f="\t\ta string\n" # Экранированные последовательности, такие как
# символы табуляции и перевода строки.
```

В одной строке можно выполнить присваивание сразу нескольким переменным:
a=5 b="a string"


При использовании подстановки имена переменных можно заключать в необяза-
тельные фигурные скобки {}. Это пригодится в том случае, когда имя переменной становится неоднозначным в окружающем контексте. В следующем примере выполняется попытка переименовать файл myfile в myfile1 с использованием переменной:

```
[me@linuxbox ~]$ filename="myfile"
[me@linuxbox ~]$ touch $filename
[me@linuxbox ~]$ mv $filename $filename1
```

mv: после 'myfile' пропущен операнд, задающий целевой файл
По команде "mv --help" можно получить дополнительную информацию.
Эта попытка не увенчалась успехом, потому что командная оболочка интерпретировала второй аргумент команды mv как имя новой (и пустой) переменной. Ниже показано, как решается подобная проблема:

```
[me@linuxbox ~]$ mv $filename ${filename}1
```

Добавив фигурные скобки, мы гарантировали, что командная оболочка не будет
интерпретировать последний символ 1 как часть имени переменной.

### ПРИМЕЧАНИЕ

Выполняя подстановку, имена переменных и команды рекомендуется заключать
в двойные кавычки, чтобы исключить разбиение строк на слова оболочкой.
Особенно важно использовать кавычки, когда переменная может содержать
имя файла.

Воспользуемся этой возможностью, чтобы добавить в отчет дополнительные данные, а именно дату и время составления отчета, а также имя пользователя, составившего отчет:

```
#!/bin/bash

TITLE="System Information Report For $HOSTNAME"
CURRENT_TIME=$(date +"%x %r %Z")
TIME_STAMP="Generated $CURRENT_TIME, by $USER"

# Программа вывода страницы с информацией о системе

echo "<html>
  <head>
    <title>$TITLE</title>
  </head>
  <body>
    <h1>$TITLE</h1>
    <p>$TIME_STAMP</p>
  </body>
</html>"
```

### Встроенные документы

Мы рассмотрели два разных метода вывода текста, и оба используют команду echo. Однако существует еще один, третий метод, который называется встроенным документом (here document), или встроенным сценарием (here script). 
Встроенный документ — это дополнительная форма перенаправления ввода/вывода, которая передает текст, встроенный в сценарий, на стандартный ввод команды. Действует это перенаправление так:

команда << индикатор
текст
индикатор

где команда — это имя команды, принимающей указанный текст через стандартный ввод, а индикатор — это строка, отмечающая конец встроенного текста. Изменим сценарий, задействовав в нем встроенный документ:

```
#!/bin/bash

TITLE="System Information Report For $HOSTNAME"
CURRENT_TIME=$(date +"%x %r %Z")
TIME_STAMP="Generated $CURRENT_TIME, by $USER"

# Программа вывода страницы с информацией о системе

cat << _EOF_

echo 
  <head>
    <title>$TITLE</title>
  </head>
  <body>
    <h1>$TITLE</h1>
    <p>$TIME_STAMP</p>
  </body>
</html>

_EOF_
```

Теперь вместо команды echo в сценарии используются команда cat и встро-
енный документ. На роль индикатора была выбрана строка _EOF_ (означает end-of-file — конец файла, распространенное соглашение), и она отмечает конец встроенного текста. Обратите внимание, что строка-индикатор должна находиться в отдельной строке, одна, и за ней не должно следовать никаких пробелов.
Но какие преимущества дало использование встроенного документа здесь? Прак-
тически никаких, кроме того, что кавычки внутри встроенных документов теряют свое специальное значение для командной оболочки. Ниже приводится пример использования встроенного документа в командной строке:

```
[me@linuxbox ~]$ foo="some text"
[me@linuxbox ~]$ cat << _EOF_
> $foo
> "$foo"
> '$foo'
> \$foo
> _EOF_
some text
"some text"
'some text'
$foo
```

Как видите, командная оболочка не обращает никакого внимания на кавычки.
Она интерпретирует их как обычные символы. Благодаря этому мы свободно
вставляем кавычки во встроенные документы. Этим обстоятельством можно воспользоваться при разработке программ составления отчетов.
Встроенные документы можно использовать с любыми командами, принимающими данные со стандартного ввода. В следующем примере встроенный документ
используется для передачи последовательности команд программе ftp, чтобы загрузить файл с удаленного FTP-сервера:

```
#!/bin/bash
# Сценарий загрузки файла через FTP
FTP_SERVER=ftp.nl.debian.org
FTP_PATH=/debian/dists/stretch/main/installer-amd64/current/images/cdrom
REMOTE_FILE=debian-cd_info.tar.gz
ftp -n << _EOF_
open $FTP_SERVER
user anonymous me@linuxbox
cd $FTP_PATH
hash
get $REMOTE_FILE
bye
_EOF_
ls -l $REMOTE_FILE
```

Если заменить оператор перенаправления << на <<-, командная оболочка будет
игнорировать начальные символы табуляции во встроенном документе. Благодаря этому во встроенный документ можно добавить отступы для большей удобочитаемости:

```
#!/bin/bash
# Сценарий загрузки файла через FTP
FTP_SERVER=ftp.nl.debian.org
FTP_PATH=/debian/dists/stretch/main/installer-amd64/current/images/cdrom
REMOTE_FILE=debian-cd_info.tar.gz
ftp -n <<- _EOF_
        open $FTP_SERVER
        user anonymous me@linuxbox
        cd $FTP_PATH
        hash
        get $REMOTE_FILE
        bye
_EOF_
ls -l $REMOTE_FILE
```

Однако пользоваться этой особенностью не всегда удобно, потому что для оформления отступов многие текстовые редакторы (и сами программисты) предпочитают использовать символы пробела вместо символов табуляции.

### Заключение

В этой главе мы приступили к разработке проекта, при помощи которого пройдем через все этапы создания сценария. Мы познакомились с переменными и константами и особенностями их использования. Они чаще других программных компонентов применяются для подстановки. Мы также увидели, как организовать вывод информации в сценарии, и познакомились с разными методами встраивания блоков текста.